# generics, annotation, final

### 지네릭스

- 지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
- 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다. 자연스럽게 코드도 더 간결해진다.
- 장점
    1. 타입의 안정성을 제공한다.
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
- 예를 들면, Collection 에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다.
    - 이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다.
    - 또한 api 를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.

### 어노테이션

- 어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법이다.
- 주석과는 그 역할이 다르지만 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다. 또 해석되는 시점을 정할 수도 있다.(Retention Policy)
- 어노테이션에는 크게 세 가지 종류가 존재한다.
    - JDK 에 내장되어 있는 built-in annotation
        - built-in annotation 은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 어노테이션이 그 대표적인 예이다
    - 어노테이션에 대한 정보를 나타내기 위한 어노테이션인 Meta annotation
        - 어노테이션의 동작 대상을 결정하는 Meta-Annotation 에도 여러 가지가 존재한다.
        - @Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)
        - @Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.
        - @Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)
    - 그리고 개발자가 직접 만들어 내는 Custom Annotation이 있다.

### fianl

- final class
    - 다른 클래스에서 상속하지 못한다.
- final method
    - 다른 메소드에서 오버라이딩하지 못한다.
- final variable
    - 변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 된다.
    - final 변수는 상수가되어 jvm의 상수 저장소(constant pool)에 관리되는걸로 알고잇음

추가적으로 혼동할 수 있는 두 가지를 추가해봤다.

- finally
    - `try-catch` or `try-catch-resource` 구문을 사용할 때, 정상적으로 작업을 한 경우와 에러가 발생했을 경우를 포함하여 마무리 해줘야하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.
- finalize()
    - keyword 도 아니고 code block 도 아닌 메소드이다. `GC`에 의해 호출되는 함수로 절대 호출해서는 안 되는 함수이다.
    - `Object` 클래스에 정의되어 있으며 GC 가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없다.
    - 또한 `finalize()` 메소드가 오버라이딩 되어 있으면 GC 가 이루어질 때 바로 Garbage Collecting 되지 않는다. GC 가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있다.