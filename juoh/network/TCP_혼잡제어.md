# TCP 혼잡제어

### 개요

- IP 계층은 네트워크 혼잡에 관해서 종단 시스템에게 어떠한 직접적인 피드백도 제공하지 않으므로, TCP는 네트워크 지원 혼잡제어보다는 **종단간의 혼잡제어**를 사용해야 한다.
- TCP 취한 접근방식은 네트워크 혼잡에 따라 연결에 트래픽을 보내는 **전송률**을 **각 송신자가 제한**하도록 하는 것이다.
    1. TCP 송신자는 자신의 연결에 송신자 전송 트래픽 **전송률을 어떻게 제한**?
    2. TCP 송신자는 자신과 목적지 사이 경로의 **혼잡을 어떻게 감지**?
    3. TCP 송신자는 종단간의 혼잡을 감지함에 따라 **송신율을 변화시키기 위해 어떤 알고리즘**?

### 1.전송률을 어떻게 제한하는가

- 송신측에서 동작하는 혼잡제어 메커니즘은 cwnd로 표시되는 혼잡 윈도우(congestion window) 변수를 기록
- 혼잡 윈도우는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한
    - 특히 송신하는 쪽에서 확인응답이 안된 데이터의 양은 min(cwmd, rwmd)를 초과 x

    ```python
    LastByteSent - LastByteAcked <= min(cwmd, rwmd)
    ```

- 송신률은 cwnd/RTT (바이트/초) 이다. 따라서 cwnd 값을 조절하여 링크에 데이터를 전송하는 비율을 조절할 수 있다.

### 2.  혼잡을 어떻게 감지하는가

- 타임아웃 또는 수신자로부터 3개의 중복된 ACK들의 수신이 발생 했을 때, TCP 송신자 측에 손실 이벤트(loss event)가 발생했다고 정의하자
- TCP는 확인응답을 혼잡 윈도우의 크기의 증가를 유발하는데 트리거 또는 클록으로 사용하므로, 자체 클로킹이라고 한다.

### 3. 송신율을 변화시키기 위해 어떤 알고리즘

- slow start
    - cwnd의 값은 일반적으로 1 MSS 초기화 >> 전송률 : MSS/RTT
    - cwnd 값을 1MSS에서 시작하여 한 전송 세그먼트가 첫 번째로 확인응답을 받을 때마다 1MSS씩 증가시키고 2개의 최대크기 세그먼트를 전송
    - 해당 세그먼트가 확인되면 하나의 MSS만큼 혼잡 윈도우를 증가 >> 그러면 4개의 MSS 혼잡 윈도우
    - 지수적 증가 반복 & 지수적 증가가 끝나는 조건
        1. 타임아웃에 의한 손실 이벤트가 있을 경우: cwnd값을 1로 하고, **새로운 슬로 스타트** 시작, 그리고 상태 변수인 **ssthresh(slow satrt threshold) 값을 cwnd/2로 설정**
        2. cwnd 값이 ssthresh 값과 같으면 **슬로 스타트는 종료**되고 **TCP 혼잡 회피 모드**로 전환 
        3. 3개의 중복 ack들이 검출되면, **빠른 재전송**을 수행하여 **빠른 회복 상태** 전환
- congestion avoidance
    - 매 RTT마다 1 MSS만큼 cwnd 값을 증가시킨다.
    - 혼잡 회피의 선형 증가 반복 & 선형 증가 끝나는 조건
        - 타임아웃 발생: cwnd의 값을 1로 하고, ssthresh의 값은 cwnd/2로 설정, 이후 빠른 회복 상태
        - 3개의 중복 ack: cwnd의 값을 반으로 나누고, ssthresh의 값은 기존 cwnd/2, 이후 빠른 회복 상태
- fast recovery
    - cwnd 값은 잃었던 세그먼트에 대한 매 중복된 ack를 수신할 때마다 1MSS만큼씩 증가
    - 빠른 회복의 선형 증가 반복 & 선형 증가 끝나는 조건
        - 타임아웃: cwnd의 값을 1로 하고, ssthresh의 값은 cwnd/2로 설정, 이후 slow start

![image_1](./TCP_혼잡제어/1.png)

### cf) 빠른 재전송(cs study용)

- Fast Retransmit (빠른 재전송)
    - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
    - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
    - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
    - 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.