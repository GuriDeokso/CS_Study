# TCP 흐름제어

### 개요

- TCP는 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해서 애플리케이션에게 흐름제어 서비스를 제공한다
- 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다.
- 흐름제어와 혼잡제어는 송신자의 억제로 동작이 비슷하지만, 명백히 서로 다른 목적을 위해 수행된다

### 흐름제어 서비스

- TCP는 송신자가 수신 윈도우라는 변수를 유지하여 흐름제어를 제공
- 수신 윈도우는 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려 주는데 사용된다.
- TCP는 전이중이므로 각 측의 송신자는 별개의 수신 윈도우 유지
- example
    - 호스트 a → 호스트 b에게 큰 파일 전송 가정
    - 호스트 b는 이 연결에 수신 버퍼 할당, 이때 할당된 수신 버퍼의 크기를 RcvBuffer라고 명명
    - 시간 나는 대로 호스트 B의 애플리케이션 프로세스는 버퍼로부터 데이터를 읽으며 다음과 같은 변수들을 정의
        - LastByteRead: 호스트 b의 애플리케이션 프로세스에 의해서 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트의 수
        - LastByteRcvd: 호스트 b에서 네트워크로부터 도착하여 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트의 수
    - TCP는 버퍼 오버플로를 허용하지 않으므로 다음 수식 가능
        - LastByteRcvd - LastByteRead ≤ RcvBuffer
    - rwnd로 명명된 수신 윈도우는 버퍼의 여유 공간으로 설정
        - rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]
    - 호스트 b는 호스트 b가 호스트 a에게 전송하는 모든 세그먼트의 윈도우 필드에 현재의 rwnd 값을 설정함으로써 연결 버퍼에 얼마만큼의 여유 공간이 있는지를 호스트 a에게 알려 준다
    - 반면 호스트 a는 LastByteSend, LastByteAcked를 유지한다
        - (LastByteSend - LastByteAcked)의 값은 호스트 a가 이 연결에 전송 확인응답이 안 된 데이터의 양이다
    - rwnd보다 작은 확인응답 데이터의 양을 유지함으로써 호스트 b의 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다.
- 이 대 rwnd = 0을 호스트 a에게 알리면 호스트 b에서 버퍼를 비우더라도 a에게 새로운 세그먼트를 보내지 않으므로 데이터 전송이 끊긴다.
    - 이러한 문제를 해결하기 위해 호스트 a가 호스트 b의 수신 윈도우가 0일 때, 1바이트 데이터로 세그먼트를 계속해서 전송하도록 요구
    - 이 세그먼트들은 수신자에 의해 긍정 확인응답
    - 결과적으로 버퍼는 비워지고 긍정 확인 응답은 0이 아닌 rwnd 값을 포함